Vehicle Rental System - Backend OOP Analysis
Generated: 2026-02-13

============================================================
1) Backend Architecture Overview
============================================================
Your project follows a layered backend structure with clear responsibilities:

- Data Access Layer:
  - src/database/db_manager.py
  - Centralizes database connection and query execution through DBManager.

- Domain Model Layer:
  - src/models/user.py
  - src/models/vehicle.py
  - Defines domain entities and role/type behavior through abstract base classes and subclasses.

- Application/Business Logic Layer (Controllers):
  - src/controllers/auth_controller.py
  - src/controllers/rental_controller.py
  - src/controllers/admin_controller.py
  - Encapsulates use-case logic (login, reservation lifecycle, analytics, user management).

- Configuration + Bootstrapping:
  - src/config.py (database settings)
  - src/database/seeder.py (schema + seed data)

- Runtime Orchestration:
  - src/main.py
  - Routes authenticated users to role-specific flows.

Even though the UI is Tkinter-based, the backend logic is properly organized into reusable classes that the views call.


============================================================
2) Encapsulation in Your Backend
============================================================
Encapsulation means bundling data with behavior and controlling direct access to internals.

A) Encapsulation in Domain Models
- In src/models/user.py and src/models/vehicle.py, internal state is stored with underscore-prefixed fields:
  - User: _user_id, _username, _first_name, _last_name, _role
  - Vehicle: _vehicle_id, _brand, _model, _year, _license_plate, _status, _daily_rate
- Public access is exposed through @property methods:
  - user_id, username, full_name, role
  - vehicle_id, description, status, daily_rate
- This protects object state from uncontrolled external mutation.

B) Encapsulation in Service Objects (Controllers)
- AuthController, RentalController, and AdminController each own a DBManager instance as self.db.
- SQL logic and business rules are hidden behind method calls such as:
  - login(), register(), change_user_password()
  - create_reservation(), approve_reservation(), cancel_reservation()
  - get_dashboard_stats(), promote_user(), get_filtered_analytics_summary()
- Views do not need to know SQL details; they only call controller methods.

C) Encapsulation in Data Access Layer
- DBManager encapsulates connection lifecycle and query mechanics:
  - connect(), disconnect(), execute_query(), fetch_one(), fetch_all()
- Callers interact through a stable API instead of handling mysql.connector directly.

D) Security Encapsulation
- Password hashing and verification are encapsulated in AuthController with bcrypt.
- Raw password handling does not leak into views or unrelated modules.


============================================================
3) Inheritance in Your Backend
============================================================
Inheritance is used to share common structure while specializing behavior.

A) User Hierarchy
- Base abstract class: User (ABC)
- Subclasses:
  - Receptionist(User)
  - Member(User)
  - Admin(User)
- Shared fields and properties come from User.
- Role-specific behavior is implemented by overriding get_permissions().

B) Vehicle Hierarchy
- Base abstract class: Vehicle (ABC)
- Subclasses:
  - Car(Vehicle)
  - Truck(Vehicle)
  - SUV(Vehicle)
  - Van(Vehicle)
  - Motorcycle(Vehicle)
- Shared vehicle fields are inherited.
- Cost calculation behavior is specialized by each subclass via calculate_rental_cost(days).

C) Why this is useful
- You avoid duplicating shared attributes and APIs.
- You can add future roles or vehicle classes with minimal impact to existing code.


============================================================
4) Polymorphism in Your Backend
============================================================
Polymorphism means one interface, many implementations, selected at runtime.

A) Runtime Role Object Creation
- In AuthController._create_user_object(), the system returns different objects based on role:
  - Member, Receptionist, or Admin
- Caller code can treat them as User while behavior (get_permissions) resolves per subclass.

B) Polymorphic Permissions
- get_permissions() exists on User as abstract and is concretely implemented by each role subclass.
- Same method call produces different results depending on actual object type.

C) Polymorphic Cost Strategy in Vehicles
- calculate_rental_cost(days) is abstract in Vehicle and implemented differently in subclasses.
- Example: Truck adds extra fee, others use direct daily-rate multiplication.

D) Role-Based Runtime Dispatch in Application Flow
- In src/main.py, dashboard routing uses current_user.role to dispatch to role-specific workflows.
- This is practical runtime behavior variation based on user type.

Note:
- The Vehicle subclasses currently express a strong polymorphic design, but controllers mostly operate on DB rows (dicts). This means part of the model polymorphism is architectural-ready but only partially leveraged in runtime flows.


============================================================
5) Abstraction in Your Backend
============================================================
Abstraction means exposing essential behavior while hiding implementation detail.

A) Abstract Base Classes (ABC)
- User and Vehicle define abstract contracts:
  - User.get_permissions()
  - Vehicle.calculate_rental_cost(days)
- Concrete subclasses must implement these methods.
- This enforces design consistency.

B) Controller Abstraction
- Controllers abstract business processes into high-level operations:
  - "login user", "create reservation", "approve request", "compute analytics"
- UI code does not work directly with SQL tables.

C) Database Abstraction
- DBManager abstracts connector setup, cursor handling, and fetch/execute patterns.
- Other modules work with Python methods instead of repetitive low-level DB code.

D) Initialization Abstraction
- seeder.py abstracts environment setup (database creation, schema apply, default data insertion) into seed_database().


============================================================
6) Backend Flow (How Classes Collaborate)
============================================================
A) Authentication Flow
1. View sends username/password to AuthController.login().
2. AuthController queries Users via DBManager.fetch_one().
3. bcrypt verifies password hash.
4. _create_user_object() returns concrete User subclass.
5. Main app routes behavior according to authenticated role.

B) Reservation Creation Flow
1. Member action calls RentalController.create_reservation().
2. Controller calculates days and cost (plus insurance rule).
3. Controller inserts reservation as Pending.
4. Status transitions are handled by receptionist/admin actions.

C) Reservation Lifecycle Flow
- Pending -> Active (approve_reservation)
- Pending/Active -> Cancelled (cancel_reservation)
- Active -> Completed + log entry (return_vehicle)
- Vehicle status synchronized with reservation state (Available/Rented).

D) Admin Analytics Flow
- AdminController aggregates SQL metrics for dashboard cards/charts:
  - revenue totals, monthly stats, status breakdowns, top vehicle type
- Filtering abstraction supports month/status parameterized analytics.


============================================================
7) OOP Strengths in Your Current Implementation
============================================================
1. Clear separation of concerns (views/controllers/models/database).
2. Solid use of abstract classes for User and Vehicle domains.
3. Practical encapsulation of DB and auth security logic.
4. Clean role object factory pattern in AuthController.
5. Business logic centralized in controller classes.


============================================================
8) Gaps and Improvement Opportunities (Backend OOP Maturity)
============================================================
1. Use domain objects more consistently
- Today many controller methods return dict rows directly from DB.
- Improvement: map rows into User/Vehicle/Reservation domain objects to fully exploit encapsulation and polymorphism.

2. Introduce a Reservation model
- Reservation currently has behavior spread in controllers.
- Improvement: create Reservation class with status-transition methods and validation rules.

3. Enforce role permissions at backend level
- get_permissions() exists but is not strongly enforced in controllers.
- Improvement: add authorization checks in controller methods.

4. Improve DBManager transaction safety
- execute_query() keeps connection open and relies on caller context.
- Improvement: use context managers/transaction wrappers and consistent connection closing.

5. Use parameterized SQL consistently
- Most methods are parameterized; keep this strict everywhere (avoid f-string SQL where possible).


============================================================
9) Concept-by-Concept Summary (Quick Matrix)
============================================================
Encapsulation:
- Hidden model fields + property accessors
- Controller methods hiding SQL/business details
- DBManager hiding DB connection/query internals

Inheritance:
- User -> Member/Receptionist/Admin
- Vehicle -> Car/Truck/SUV/Van/Motorcycle

Polymorphism:
- get_permissions() dynamic behavior by role subclass
- calculate_rental_cost() dynamic behavior by vehicle subclass
- Runtime role-specific object creation in AuthController

Abstraction:
- ABC contracts in models
- Controller APIs as use-case abstractions
- DBManager as storage abstraction


============================================================
10) Final Assessment
============================================================
Your backend already demonstrates all four core OOP principles in a meaningful way, especially through abstract class design, controller encapsulation, and role-oriented object modeling. The architecture is strong for a Tkinter-based project and can scale further by introducing richer domain entities (especially Reservation), stronger permission enforcement in controllers, and fuller runtime use of polymorphic model objects.


============================================================
11) OOP Code Snippet Examples from Your System
============================================================

ENCAPSULATION EXAMPLE 1 (Private-like attributes + property access)
------------------------------------------------------------
class User(ABC):
  def __init__(self, user_id, username, first_name, last_name, role):
    self._user_id = user_id
    self._username = username
    self._first_name = first_name
    self._last_name = last_name
    self._role = role

  @property
  def user_id(self):
    return self._user_id

  @property
  def username(self):
    return self._username

  @property
  def full_name(self):
    return f"{self._first_name} {self._last_name}"

Located in: src/models/user.py (line 3; properties around lines 11-22)


ENCAPSULATION EXAMPLE 2 (DB internals hidden behind methods)
------------------------------------------------------------
class DBManager:
  def __init__(self):
    self.conn = None
    self.cursor = None

  def fetch_one(self, query, params=None):
    self.connect()
    self.cursor.execute(query, params or ())
    result = self.cursor.fetchone()
    self.disconnect()
    return result

  def fetch_all(self, query, params=None):
    self.connect()
    self.cursor.execute(query, params or ())
    result = self.cursor.fetchall()
    self.disconnect()
    return result

Located in: src/database/db_manager.py (fetch_one line 39, fetch_all line 46)


INHERITANCE EXAMPLE 1 (Role hierarchy)
------------------------------------------------------------
class User(ABC):
  @abstractmethod
  def get_permissions(self):
    pass

class Receptionist(User):
  def get_permissions(self):
    return ["manage_vehicles", "manage_users", "view_all_reservations", "update_logs", "view_returns"]

class Member(User):
  def get_permissions(self):
    return ["search_vehicles", "reserve_vehicle", "view_my_reservations"]

class Admin(User):
  def get_permissions(self):
    return ["all_access"]

Located in: src/models/user.py (User line 3, Receptionist line 36, Member line 40, Admin line 44)


INHERITANCE EXAMPLE 2 (Vehicle hierarchy)
------------------------------------------------------------
class Vehicle(ABC):
  @abstractmethod
  def calculate_rental_cost(self, days):
    pass

class Car(Vehicle):
  def calculate_rental_cost(self, days):
    return self._daily_rate * days

class Truck(Vehicle):
  def calculate_rental_cost(self, days):
    return (self._daily_rate * days) + 500

Located in: src/models/vehicle.py (Vehicle line 3, Car line 33, Truck line 37)


POLYMORPHISM EXAMPLE 1 (Same method, different subclass behavior)
------------------------------------------------------------
class Car(Vehicle):
  def calculate_rental_cost(self, days):
    return self._daily_rate * days

class Truck(Vehicle):
  def calculate_rental_cost(self, days):
    return (self._daily_rate * days) + 500

class Motorcycle(Vehicle):
  def calculate_rental_cost(self, days):
    return self._daily_rate * days

Located in: src/models/vehicle.py (Car line 33, Truck line 37, Motorcycle line 50)


POLYMORPHISM EXAMPLE 2 (Runtime object factory by role)
------------------------------------------------------------
def _create_user_object(self, data):
  role = data['role']
  if role == 'Receptionist':
    return Receptionist(data['user_id'], data['username'], data['first_name'], data['last_name'], role)
  elif role == 'Member':
    return Member(data['user_id'], data['username'], data['first_name'], data['last_name'], role)
  elif role == 'Admin':
    return Admin(data['user_id'], data['username'], data['first_name'], data['last_name'], role)
  return None

Located in: src/controllers/auth_controller.py (line 79)


ABSTRACTION EXAMPLE 1 (Abstract contracts using ABC)
------------------------------------------------------------
from abc import ABC, abstractmethod

class Vehicle(ABC):
  @abstractmethod
  def calculate_rental_cost(self, days):
    pass

class User(ABC):
  @abstractmethod
  def get_permissions(self):
    pass

Located in: src/models/vehicle.py (Vehicle class line 3, abstract method line 30) and src/models/user.py (User class line 3, abstract method line 33)


ABSTRACTION EXAMPLE 2 (Business operation abstraction in controller)
------------------------------------------------------------
def create_reservation(self, user_id, vehicle_id, start_date, end_date, insurance):
  delta = (end_date - start_date).days
  if delta < 1: delta = 1

  v_query = "SELECT daily_rate FROM Vehicles WHERE vehicle_id = %s"
  vehicle = self.db.fetch_one(v_query, (vehicle_id,))
  base_cost = float(vehicle['daily_rate']) * delta

  total_cost = base_cost
  if insurance:
    total_cost += (500 * delta)

  ins_query = """
    INSERT INTO Reservations (user_id, vehicle_id, start_date, end_date, insurance_added, total_cost, status)
    VALUES (%s, %s, %s, %s, %s, %s, 'Pending')
  """
  self.db.execute_query(ins_query, (user_id, vehicle_id, start_date, end_date, insurance, total_cost))
  return True

Located in: src/controllers/rental_controller.py (line 29)
